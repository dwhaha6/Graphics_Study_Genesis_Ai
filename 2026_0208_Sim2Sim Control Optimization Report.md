# 최적화 과정

### 최적화를 위한 Loss 및 State 정의

최적화는 Genesis 시뮬레이터에서 생성된 차량 상태와 Blender 기반 Ground Truth 데이터 간의 차이 최소화를 목표로 진행하였습니다. a,k 등 각 state의 오차는 정규화 스케일(표준편차) 값으로 나누어 단위가 달라도 동등하게 비교가 되게 진행하였습니다

| State | 정의 | 정규화 스케일 | 가중치 |
|-------|------|--------------|--------|
| **a (acceleration)** | 종방향 가속도 `(v[t] - v[t-1]) / dt` | 0.27 m/s² | 1.0 |
| **k (curvature)** | 곡률 `yaw_rate / v` (단, \|v\| > 0.5) | 0.064 1/m | 1.0 |


---
**추가 Loss 항목:**

| 항목 | 정의 | 가중치 | 비고 |
|------|------|--------|------|
| **pos (position)** | 2D 위치 오차 `sqrt((x-x_target)² + (y-y_target)²)` | 1.0 |정규화 스케일 1.0m
| **smooth (regularization)** | 제어 연속성 `(s[t]-s[t-1])² + (t[t]-t[t-1])²` | 0.1 | 급격한 제어 변화 방지용  |

---
- 가중치는 공평하게 분배

### 최적화 원리 1 (Rolling Horizon 구조)

최적화는 **Rolling Horizon** 방식으로 진행되며, 전체 궤적을 한 번에 최적화하지 않고 일정 프레임 간격으로 나누어 수행하였습니다.

- **Horizon**: 한 번의 최적화에서 예측하는 **미래 프레임 수는 10 프레임**
- **Execute Steps**: 최적화 결과 중 실제로 적용되는 프레임 수는 **3 프레임**
- 즉, 10 프레임 구간을 예측 최적화한 뒤, 앞선 3 프레임만 실제 제어값으로 확정하고, 다음 3 프레임 이후의 지점에서 다시 10 프레임 최적화를 반복
- 이렇게 **3 프레임 간격으로 최적화가 진행**되며, 각 최적화 구간은 7 프레임이 다음 단계와 **오버랩**되어 궤적 연속성을 확보

![](./이미지/최적화설명1.png)

![](./이미지/최적화설명2.png)
---

### 최적화 원리 2 (최적화 알고리즘)

최적화는 **scipy.optimize.minimize**의 **L-BFGS-B** 알고리즘을 사용

1. **초기값**: Blender 데이터에서 추출한 제어값(steer, throttle)에 전역 스케일(`steer_scale=1.2`, `throttle_scale=0.8`)을 적용한 값을 초기 추정치로 사용
    - 전역 스케일 값은 교수님께서 올려주신 global 방식을 참고하여 현재 오버피팅을 목표로하는 데이터를 기준으로 steer, throttle 값을 바꿔가며 pos_err loss가 가장 적었던 스케일 값을 구했습니다, 최적화 시작 전 이 스케일값 적용 후 최적화를 진행했습니다.

|파라미터|	탐색 범위|
|---| ---|
|steer_scale|	0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2|
|throttle_scale|	0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.5, 2.0|

2. **시뮬레이션 기반 평가**: 주어진 제어 시퀀스로 차량을 실제로 주행시키고, 해당 Horizon 구간 동안의 누적 Loss를 계산함
3. **반복 탐색**: L-BFGS-B 알고리즘이 제어값을 반복적으로 수정하며 Loss가 가장 작아지는 (steer, throttle) 시퀀스를 탐색함
4. **제약 조건**: steer는 [-0.61, 0.61] rad, throttle은 [-1.0, 1.0] 범위로 클리핑 됨

---

### 최적화 후처리

최적화 완료 후, 일부 구간(특히 급격한 곡률 변화 구간)에서 **제어값의 수동 보정**이 수행하였습니다.   
-> 결국 정답 데이터를 가능한 정확하게 찾는 것이 중요하기에 일부 구간의 제어 값을 보정하여도 괜찮을 것이라 판단하였습니다.

---

### 최적화 결과

https://github.com/user-attachments/assets/885eb0ad-a8f8-4e8a-a577-b7299c79adb3

- 수동 보정 전

https://github.com/user-attachments/assets/62dc657c-8bd7-4c80-ad60-5199c6711639

- 수동 보정 후

---

## 최적화 이후 과정

Ground Truth 데이터(`optimized_ak_manual_fix.csv`)로부터 학습 데이터 추출을 완료하였으며, 이를 기반으로 **지도학습 파이프라인**을 설계 중에 있습니다.

### MLP 구조

| 구분 | 상세 |
|------|------|
| **입력층 (Input)** | 3차원: `[target_a, target_k, v_gen]` <br> (목표 가속도, 목표 곡률, 현재 속도) |
| **은닉층 (Hidden)** | 64차원 × 3개 레이어, 활성화 함수: ReLU |
| **출력층 (Output)** | 2차원: `[steer, throttle]` |
| **총 파라미터 수** | **8,706개** |


- Layer 1: 3×64 (weight) + 64 (bias) = 256
- Layer 2: 64×64 + 64 = 4,160
- Layer 3: 64×64 + 64 = 4,160
- Layer 4: 64×2 + 2 = 130
- **합계: 8,706개**

- 아직 지도학습은 진행 전입니다.
